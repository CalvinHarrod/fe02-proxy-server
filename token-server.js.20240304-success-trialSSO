require('dotenv').config();
const secretKey = process.env.SECRET_KEY;

const express = require('express');
const jwt = require('jsonwebtoken');
const cors = require('cors');
const url = require('url');
const { createProxyMiddleware } = require('http-proxy-middleware');

const bodyParser = require('body-parser');

// Create a new lowdb instance
const low = require('lowdb');
const FileSync = require('lowdb/adapters/FileSync');

const fs = require('fs');
const fsp = require('fs').promises;

// Check if the file exists and is not empty
if (!fs.existsSync('token-db.json') || fs.readFileSync('token-db.json', 'utf8').trim() === '') {
  // If file does not exist or is empty, initialize it with a default value
  fs.writeFileSync('token-db.json', JSON.stringify({ tokens: [] }, null, 2), 'utf8');
}

const adapter = new FileSync('token-db.json');
let db;

try {
  // Try to load the database
  db = low(adapter);
} catch (error) {
  // If an error occurred (e.g., the JSON file is invalid), initialize it with default values
  fs.writeFileSync('token-db.json', JSON.stringify({ tokens: [] }, null, 2), 'utf8');
  db = low(adapter);
}

const app = express();
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cors());
app.use(express.json());

const listenPort = 7777;

// Define the isTokenExpired function
function isTokenExpired(token) {
  // Retrieve the token data from the database
  const tokenData = db.get('tokens').find({ token }).value();

  if (!tokenData) {
    return true;
  }

  // Check if the token has expired
  return Date.now() > new Date(tokenData.expiry).getTime();
}

let tokenExpiration = 5 * 60 * 1000; // 5 minutes in milliseconds

// Convert to number if necessary
if (typeof tokenExpiration === 'string') {
  tokenExpiration = Number(tokenExpiration);
}

// Check if tokenExpiration is a number
if (isNaN(tokenExpiration)) {
  console.error('Invalid token expiration');
  return;
}

const tokenExpiryTimestamp = Date.now() + tokenExpiration * 60 * 1000;

const { format } = require('date-fns');

async function logToFile(message) {
  const timestamp = format(new Date(), 'yyyyMMdd HH:mm:ss');
  const logMessage = `${timestamp} ${message}\n`;
  await fsp.writeFile('token-server.log', logMessage, { encoding: 'utf8', flag: 'a' });
}

app.use((req, res, next) => {
  logToFile(`Received a request to ${req.path} with body: ${JSON.stringify(req.body)}`);
  next();
});

db.defaults({ tokens: [] })
  .write();

app.post('/init', async (req, res) => {
  const token = await generateAndStoreToken(req.body.mobile);
  await logToFile(`Generated token: ${token}`);
  res.json({ token });
});

app.delete('/delete/:mobile', (req, res) => {
  const mobile = req.params.mobile;
  console.log(`Received delete request for mobile: ${mobile}`);

  // Check if a token for the mobile number exists
  const existingToken = db.get('tokens').find({ mobile }).value();

  if (existingToken) {
    // If a token exists, remove it
    db.get('tokens').remove({ mobile }).write();
    console.log(`Token for mobile: ${mobile} deleted successfully`);
    res.json({ message: 'Token deleted successfully' });
  } else {
    console.log(`Token for mobile: ${mobile} not found`);
    res.status(404).json({ message: 'Token not found' });
  }
});

app.post('/auth', async (req, res) => {
  const token = req.body.token;

  if (!token) {
    await logToFile('No token provided.');
    return res.status(400).json({ message: 'No token provided.' });
  }

  await logToFile(`Received token: ${token}`);

  jwt.verify(token, secretKey, async (err, decoded) => {
    if (err) {
      await logToFile('Failed to authenticate token.');
      return res.status(401).json({ message: 'Failed to authenticate token.' });
    }

    // Retrieve the token data from the database
    const tokenData = db.get('tokens').find({ token }).value();

    if (tokenData) {
      // Convert the timestamp to a date
      const expiryDate = new Date(tokenData.expiry);

      // Check if the token has expired
      if (Date.now() > expiryDate.getTime()) {
        await logToFile('Token has expired.');
        return res.status(401).json({ message: 'Token has expired.' });
      }

      // Format the date
      const formattedExpiryDate = format(expiryDate, 'yyyyMMdd HH:mm');

      await logToFile(`Token is valid. The next expiry date is ${formattedExpiryDate}`);
      res.status(200).json({ message: 'Token is valid.' });
    } else {
      await logToFile('Token not found.');
      return res.status(403).json({ message: 'Token not found.' });
    }
  });
});

app.get('/checkToken/:mobile', (req, res) => {
  const mobile = req.params.mobile;
  const token = db.get('tokens').find({ mobile }).value();

  if (token && !isTokenExpired(token)) {
    res.status(200).send(`http://192.168.42.11:8080/eform-application/form_main?mobile=${mobile}`);
  } else {
    res.status(401).send('Token is not valid or expired');
  }
});

app.get('/reDirect/:mobile', async (req, res) => {
  const mobile = req.params.mobile;
  const token = req.query.token;

  const incomingLink = `${req.protocol}://${req.get('host')}${req.originalUrl}`;
  await logToFile(`Incoming link: ${incomingLink}`);

  // Authenticate the token
  const tokenData = db.get('tokens').find({ token }).value();
  const tokenIsValid = tokenData && !isTokenExpired(token);

  await logToFile(`Token is valid: ${tokenIsValid}`);

  if (tokenIsValid) {
    // const redirectUrl = `http://192.168.42.11:8080/eform-application/form_main?mobile=${mobile}`;
    const redirectUrl = `http://10.161.169.13:9700/eform-application/form_main?mobile=${mobile}`;
    await logToFile(`Redirect to: ${redirectUrl}`);
    res.redirect(redirectUrl);
  } else {
    await logToFile('Token is not valid or expired');
    res.status(401).send('Token is not valid or expired');
  }
});


function authenticateToken(token) {
  // Read the JSON database
  const db = JSON.parse(fs.readFileSync('db.json', 'utf8'));

  // Search for the token in the database
  const tokenIsValid = db.tokens.includes(token);

  return tokenIsValid;
}

async function generateAndStoreToken(mobile) {
  // Generate a new token
  const newToken = jwt.sign({ mobile }, secretKey, { expiresIn: tokenExpiration });

  // Calculate the token expiry timestamp
  const tokenExpiryTimestamp = Date.now() + tokenExpiration;

  // Convert the timestamp to a date
  const expiryDate = new Date(tokenExpiryTimestamp);

  // Format the date
  const formattedExpiryDate = format(expiryDate, 'yyyy-MM-dd HH:mm');

  // Check if a token for the mobile number already exists
  const existingToken = db.get('tokens').find({ mobile }).value();

  if (existingToken) {
    // If a token exists, remove it
    db.get('tokens').remove({ mobile }).write();
  }

  // Calculate the current timestamp and format it
  const currentDate = new Date();
  const formattedCreateDate = format(currentDate, 'yyyy-MM-dd HH:mm');

  // Store the new token, mobile number, Create Date, and token expiry timestamp in the database
  db.get('tokens')
    .push({ token: newToken, mobile, CreateDate: formattedCreateDate, expiry: formattedExpiryDate })
    .write();

  await logToFile(`New token generated for mobile ${mobile} with expiry timestamp ${formattedExpiryDate}`);

  return newToken;
}


async function checkTokenValidity(token) {
  // Retrieve the token data from the database
  const tokenData = db.get('tokens').find({ token }).value();

  if (!tokenData) {
    return { isValid: false, isExpired: true };
  }

  // Check if the token has expired
  const isExpired = Date.now() > new Date(tokenData.expiry).getTime();

  return { isValid: true, isExpired };
}







app.listen(listenPort, () => logToFile(`Server running on port ${listenPort}`));
